Report on
“No Silver Bullet-Essence and Accident in Software Engineering”

I agree with the article on there is no silver bullet. But I think certain aspects of the software improvement really help the essence of software development.

The article first divides the software construction, following Aristotle, with essence and accidents. The two basic tasks, one is essential task, which deals with conceptual structure, like abstract data type, etc. And another one basic task is accidental task, which deals with the actual implementation of the abstract data structure on programming languages and on actual machines with speed and space constraints. So that the essence is more software-related, while the accident is more hardware-related.

From now on I’ll try to discuss some parts of the article.
First, I think the division is fair. I believe the software and hardware are related.
For example the article mentions Workstations, it is much more powerful today than 26 years later, according to Moore’s Law[1]. Actually, when hardware gets more powerful, cheaper, and with the revolutionary ‘big data’ generating companies-Facebook, Google, banking companies, they have too much of data that they don’t know what to do with it. So the abstract conceptual model like “MapReduce” comes out. So, the hardware advancement indeed make the software part needs to do things that never been done before. They are related and affect each other.
 
This article is produced on 1986, which is 26 years ago. The hardware is faster, and some of the “hopes for the silver” techniques got a profound development as well. For OO design, we have Java, which now becomes the first language that a lot of computer science schools teaching.  It helps to learn OO and the software industry out there uses it as well. If it doesn’t solve the abstract concept problem (with the OO designs), it will not be adopted by industry so widely(And of course its platform independent feature is also a beneficial one).  As well as C++, which is also Object-Oriented. 

I don’t agree with the author with Environments and tools part either. We have our project in this course built on XAMPP platform, which integrated the programming language-PHP, lauguage development framework-Cakephp, Web Server-Apache, Database Host-MySQL, Testing tools-PHPUnit under pear, all in one package. It saves a lot of time to configure the Apache server, to run the database query by programmers themselves(which is also error-prone). And since the Cakephp introduces new syntax,  and introduces the MVC framework, it makes building website on the overall platform extremely easy and fun, compared to using php by itself and do all the settings as well. 

And for the Graphical programming, I don’t totally agree with the author as well. There are certain software development that in nature, is conformed with the graphical programming. One example is Arduino, an open-source single-board electronics prototyping platform, based on flexible, easy to use hardware and software[2]. It is in nature to just draw the microcontroller pieces and ports in graphics, instead of programming. And also, I think the graphical programming can help beginners, or even kids, learn the conceptual thinking of object-oriented design, or with the work-flows. I mean, in elementary software programming, graphical programming is a good start. Just like the ‘Head First Java’ book, which is full of graphics to help you understand.

And the author also proposed several ‘promising attacks’ on the conceptual essence.
First is ‘not to build at all’. I couldn’t agree more. I can give you a simple example. When companies want to hire people through Internet, they got to have a piece of software to collect the candidates’ information. As time goes on, 26 years later, there has several ‘software as a service’ company to provide this piece of software to any company, which saves a lot of trouble if the company wants to build one from scratch.  This ‘SaaS’[3] model is quite popular these days. And this is indeed ‘the most profound long run trend’. And the article also mentioned about the ‘simple database tools’, ‘These powerful tools…”. Today, the database tool is very powerful now, besides traditional relational database systems, you have NoSQL[4] database, postgresql, and MongoDB[5], and most of them are open-source, which makes it free of charge and tech people can contribute, the product helps the world. The open-source community is just awesome!
And for this “Buy versus build” point, I also wants to point out that “the user of n copies of a software system effectively multiplies the productivity of its developers by n”. I agree with this sentence. I think good software like Windows Word, let so many users worldwide generate marginal profit on using it, which makes the Word software costless. And in this way, software can be cheap when a lot of users are using it.

And for the “Requirement  refinement and rapid programming” and “Incremental development-grow, not build, software”, I found them very in conformity with the spirit of  a development methodology, which brings out 1999, 13 years later-extreme programming, which is “ intended to improve software quality and responsiveness to changing customer requirements”[6]
And this is indeed a trend for future software development also.
And for the “Great Designer” part, I think the industry has its evidence. The springing up startups are mostly found by one or a few people, who themselves are often great designers. And they respect developers when they run the company. The Fog Creek Software respect the employees, assign their own office space and quiet room, in the mean time, the lounge can gather people into discussion. [7]

Reference:

[1] http://en.wikipedia.org/wiki/Moore's_law
[2] http://www.arduino.cc/
[3]  http://en.wikipedia.org/wiki/Software_as_a_service
[4] http://en.wikipedia.org/wiki/Nosql
[5] http://www.mongodb.org/
[6] http://en.wikipedia.org/wiki/Extreme_programming#History
[7] www.youtube.com/watch?v=j3O3UHSGLng
